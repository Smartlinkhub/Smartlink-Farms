"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractMethod = void 0;
var wallet_1 = require("../../wallet");
var contract_1 = require("../contract");
var errors_1 = require("../errors");
/**
 * @description Utility class to send smart contract operation
 * The format for the arguments is the flattened representation
 */
var ContractMethod = /** @class */ (function () {
    function ContractMethod(provider, address, parameterSchema, name, args, isMultipleEntrypoint, isAnonymous) {
        if (isMultipleEntrypoint === void 0) { isMultipleEntrypoint = true; }
        if (isAnonymous === void 0) { isAnonymous = false; }
        this.provider = provider;
        this.address = address;
        this.parameterSchema = parameterSchema;
        this.name = name;
        this.args = args;
        this.isMultipleEntrypoint = isMultipleEntrypoint;
        this.isAnonymous = isAnonymous;
    }
    ContractMethod.prototype.validateArgs = function (args, schema, name) {
        var sigs = schema.ExtractSignatures();
        if (!sigs.find(function (x) { return x.length === args.length; })) {
            throw new errors_1.InvalidParameterError(name, sigs, args);
        }
    };
    ;
    Object.defineProperty(ContractMethod.prototype, "schema", {
        /**
         * @description Get the schema of the smart contract method
         */
        get: function () {
            return this.isAnonymous
                ? this.parameterSchema.ExtractSchema()[this.name]
                : this.parameterSchema.ExtractSchema();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @description Get the signature of the smart contract method
     */
    ContractMethod.prototype.getSignature = function () {
        var _this = this;
        if (this.isAnonymous) {
            var sig = this.parameterSchema.ExtractSignatures().find(function (x) { return x[0] === _this.name; });
            if (sig) {
                sig.shift();
                return sig;
            }
        }
        else {
            var sig = this.parameterSchema.ExtractSignatures();
            return (sig.length == 1) ? sig[0] : sig;
        }
    };
    /**
     *
     * @description Send the smart contract operation
     *
     * @param Options generic operation parameter
     */
    ContractMethod.prototype.send = function (params) {
        if (params === void 0) { params = {}; }
        if (this.provider instanceof wallet_1.Wallet) {
            return this.provider.transfer(this.toTransferParams(params)).send();
        }
        else {
            return this.provider.transfer(this.toTransferParams(params));
        }
    };
    /**
     *
     * @description Create transfer params to be used with TezosToolkit.contract.transfer methods
     *
     * @param Options generic transfer operation parameters
     */
    ContractMethod.prototype.toTransferParams = function (_a) {
        var _b, _c;
        var _d = _a === void 0 ? {} : _a, fee = _d.fee, gasLimit = _d.gasLimit, storageLimit = _d.storageLimit, source = _d.source, _e = _d.amount, amount = _e === void 0 ? 0 : _e, _f = _d.mutez, mutez = _f === void 0 ? false : _f;
        var fullTransferParams = {
            to: this.address,
            amount: amount,
            fee: fee,
            mutez: mutez,
            source: source,
            gasLimit: gasLimit,
            storageLimit: storageLimit,
            parameter: {
                entrypoint: this.isMultipleEntrypoint ? this.name : contract_1.DEFAULT_SMART_CONTRACT_METHOD_NAME,
                value: this.isAnonymous
                    ? (_b = this.parameterSchema).Encode.apply(_b, __spreadArray([this.name], __read(this.args))) : (_c = this.parameterSchema).Encode.apply(_c, __spreadArray([], __read(this.args))),
            },
        };
        return fullTransferParams;
    };
    return ContractMethod;
}());
exports.ContractMethod = ContractMethod;
//# sourceMappingURL=contract-method-flat-param.js.map